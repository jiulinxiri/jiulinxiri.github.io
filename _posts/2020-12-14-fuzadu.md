---
title: 算法的时间空间复杂度
author: jiulinxiri
date: 2020-12-14 09:36:00 +0800
categories: [转载, 概念]
tags: [algorithm]
math: true
---

不同算法之间的优劣主要从`时间`和`空间`两个维度去衡量。
* 时间维度：执行当前算法所消耗的时间，通常用`时间复杂度`来描述
* 空间维度：执行当前算法需要占用多少内存空间，通常用`空间复杂度`来描述

## 时间复杂度
时间复杂度通用的表示方式`大O符号表示法` $$T(n)=O(f(n))$$

先看个例子
```java
for (int i = 0; i < n; i++) {
    j = i;
    j++;
}
```
通过`大O符号表示法`，这段代码的时间复杂度为：O(n), 为什么呢？

在`大O符号表示法`中，时间复杂度的公式是: $$ T(n)=O(f(n)) $$, 其中f(n)表示每行代码的执行次数之和，而O表示正比例关系，这个公式的全称是: **算法的渐进时间复杂度**。

我们继续看上边的🌰️，假设每行代码的执行时间都是一样的，用`1颗粒时间`来表示,那么这个🌰️第一行耗时为1个颗粒时间，第三行的执行时间是n个颗粒时间，第四行的执行时间也是 n 个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1 颗粒时间 + n 颗粒时间 + n 颗粒时间，即（1+2n）个颗粒时间，即 $$ T(n) = (1+2n)* $$ 颗粒时间。从这个结果可以看出，这个算法的耗时是随 n 的变换而变化，因此，我们可以简化的将这个算法的时间复杂度表示为: $$ T(n) = O(n) $$

常见的时间复杂度量级有:
* 常数阶O(1)
* 对数阶O(logN)
* 线性阶O(n)
* 线性对数阶O(nlogN)
* 平方阶O(n^2)
* 立方阶O(n^3)
* K次方阶O(n^k)
* 指数阶O(2^n)

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

### 常数阶O(1)
无论代码执行多少行，只要没有循环等复杂结构，那这个代码的时间复杂度都是 O(1)。比如
```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```
上述的代码在执行的时候，它消耗的时间并不随某个变量的增长而增长，那么无论这类代码有多长，都可以用 O(1) 来代表它的时间复杂度。

### 线性阶O(n)
```java
for (int i = 0; i < n; i++) {
    j = i;
    j++;
}
```
这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

### 对数阶O(logN)
```java
int i = 1;
while(i < n) {
    i = i * 2;
}
```
从上边的代码可以看出，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近。假设循环x次之后，i 就大于 n 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n。
也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)。

### 线性对数阶O(nlogN)
线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。
```java
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

### 平方阶O(n²)
平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。
```java
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```
这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²) 
如果将其中一层循环的n改成m，即
```java
for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

那它的时间复杂度就变成了 O(m*n)

### 立方阶O(n³)、K次方阶O(n^k)
参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。


## 空间复杂度
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

### 空间复杂度 O(1)
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```
代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

### 空间复杂度 O(n)

```java
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```
这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

### 复杂度分析
![复杂度分析](https://vip2.loli.net/2020/12/15/qJ6jl5FNcxYDfyg.png){:width="650"}
_复杂度分析_

[PNG原文件下载](https://115.com/s/sw30mpl33mg?password=pcc8&#
复杂度分析.png)
### 参考
[数据结构与算法之美](https://time.geekbang.org/column/intro/126)<br>
[算法的时间与空间复杂度（一看就懂）](https://zhuanlan.zhihu.com/p/50479555)