---
title: 十大排序算法分类
author: jiulinxiri
date: 2020-12-11 18:00:00 +0800
categories: [转载]
tags: [algorithm, data structure]
toc: true
---

## 十大排序算法分类
十大排序算法基于`比较与非比较`维度的分类如下图所示：

![十大排序算法分类](https://vip2.loli.net/2020/12/11/TjPyosWYNfB2kva.png){: width="400"}
_十大排序算法分类_

## 交换类

### 冒泡排序
冒泡排序，又称起泡排序，它是一种基于交换的排序典型，也是快排思想的基础。冒泡排序是一种稳定的排序算法，时间复杂度为O(n^2)。基本的思想：**循环遍历多次，每次从前往后把大元素向后调，每次确定一个最大(最小)元素，多次后达到排序序列**

> 时间复杂度相关，请参考 [《算法的时间空间复杂度》](https://jiulinxiri.github.io/posts/fuzadu/)

基本思想（大元素往后调）
* 从第一个元素开始往后遍历，每到一个位置判断是否比后面的元素大，如果比后面元素大，那么就交换两者大小，然后继续向后，这样的话进行一轮之后就可以保证「**最大的那个数被交换交换到最末的位置可以确定**」。
* 第二次同样从开始起向后判断着前进，如果当前位置比后面一个位置更大的那么就和他后面的那个数交换。但是有点注意的是，这次并不需要判断到最后，只需要判断到倒数第二个位置就行(因为第一次我们已经确定最大的在倒数第一，这次的目的是确定倒数第二)
* 同理，后面的遍历长度每次减一，直到第一个元素使得整个元素有序。

以下列`2 9 6 1 4 3 8 7 5`序列为例


![RPReplay](https://vip2.loli.net/2020/12/15/tEAcjG9SF68yQpn.gif){: width="300"}
_Bubble Sort_

代码实现:
```java
private void bubbleSort(int a[]) {
    for (int i = a.length - 1; i >= 0 ; i--) {
        for (int j = 0; j < i; j++) {
            if (a[j] > a[j+1]) {
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
}
```
### 快速排序
快速排序是对冒泡排序的一种改进，采用递归分治的方法。相对于冒泡排序，快速排序是一种不稳定的排序，时间复杂度最坏是O(n^2), 平均时间复杂度为O(nlogn),最好情况的时间复杂度为O(nlogn)。

基本思想:
* 快排需要将序列变成两部分，就是 **序列左边全部小于一个数，序列右边全部到大于一个数**，然后利用递归的思想再将左序列当成一个完整的序列再进行排序，同样把序列的右侧也当成一个完整的序列进行排序。
* 其中这个数在这个序列中是可以随机取的，可以取最左边，可以取最右边，当然也可以取随机数。但是**通常**不优化情况我们取最左边的那个数。

![ba](https://vip1.loli.net/2020/12/15/k9SC58Roqaue6XN.gif){:width="300"}
_Quick Sort_


```java
private void quickSort(int[] a, int left, int right) {
    int low = left;
    int hight = right;
    int k = a[low]; //待排序的第一个元素作为基准元素
    if (low <= hight) { //待排序的元素至少有两个的情况
        if (low != hight) { //从左右两边交替扫描，直到low = hight
            while (low < hight && a[hight] >= k) {
                hight --;//从右往左扫描，找到第一个比基准元素小的元素
            }
            a[low] = a[hight];//找到这种元素a[low]后与a[hight]交换
            while (low < hight && a[low] >= k) {
                low--; //从左往右扫描，找到第一个比基准元素大的元素
            }
            a[hight] = a[low]; //找到这种元素a[low]后，与a[hight]交换
        }
        a[low] = k; //基准元素归位
        quickSort(a, left, low-1);//对基准元素左边的元素进行递归排序
        quickSort(a, low+1, right);//对基准元素右边的进行递归排序
    }
}
```

## 插入类排序
### 直接插入排序
直接插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对未排序的数据，在已排序序列中从后向前扫描，找到相应的位置并插入。时间复杂度为O(n^2)。

具体步骤:
* 选取当前位置(当前位置前面已经有序) 目标就是将当前位置数据插入到前面合适位置
* 向前枚举或者二分查找，找到待插入的位置
* 移动数组，赋值交换，达到插入效果


![](https://vip2.loli.net/2020/12/15/hvDLOydAawtfFmK.jpg){: width="300"}
_原始序列_

![insert](https://vip2.loli.net/2020/12/15/316CvjeKFSspfoi.gif){: width="350"}
_Insert Sort_


```java
private void insertSort(int[] a) {
    int temp = 0;
    for (int i = 1; i < a.length; i++) { // 未排序数据
        temp = a[i]; // 待插入的数
        for (int j = i - 1; j >= 0; j--) { // 已排序序列
            if (a[j] > temp) {
                a[j+1] = a[j];
                a[j] = temp;
            } else {
                break;
            }
        }
    }
}
```



