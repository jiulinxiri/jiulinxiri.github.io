---
title: 十大排序算法分类
author: jiulinxiri
date: 2020-12-11 18:00:00 +0800
categories: [转载]
tags: [algorithm, data structure]
toc: true
---

## 十大排序算法分类
十大排序算法基于`比较与非比较`维度的分类如下图所示：

![十大排序算法分类](https://vip2.loli.net/2020/12/11/TjPyosWYNfB2kva.png){: width="400"}
_十大排序算法分类_

## 交换类

### 冒泡排序
冒泡排序，又称起泡排序，它是一种基于交换的排序典型，也是快排思想的基础。冒泡排序是一种稳定的排序算法，时间复杂度为O(n^2)。基本的思想：**循环遍历多次，每次从前往后把大元素向后调，每次确定一个最大(最小)元素，多次后达到排序序列**

> 时间复杂度相关，请参考 [《算法的时间空间复杂度》](https://jiulinxiri.github.io/posts/fuzadu/)

基本思想（大元素往后调）
* 从第一个元素开始往后遍历，每到一个位置判断是否比后面的元素大，如果比后面元素大，那么就交换两者大小，然后继续向后，这样的话进行一轮之后就可以保证「**最大的那个数被交换交换到最末的位置可以确定**」。
* 第二次同样从开始起向后判断着前进，如果当前位置比后面一个位置更大的那么就和他后面的那个数交换。但是有点注意的是，这次并不需要判断到最后，只需要判断到倒数第二个位置就行(因为第一次我们已经确定最大的在倒数第一，这次的目的是确定倒数第二)
* 同理，后面的遍历长度每次减一，直到第一个元素使得整个元素有序。

以下列`2 9 6 1 4 3 8 7 5`序列为例


![RPReplay](https://vip2.loli.net/2020/12/15/tEAcjG9SF68yQpn.gif){: width="300"}
_Bubble Sort_

代码实现:
```java
private void bubbleSort(int a[]) {
    for (int i = a.length - 1; i >= 0 ; i--) {
        for (int j = 0; j < i; j++) {
            if (a[j] > a[j+1]) {
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
}
```
### 快速排序
快速排序是对冒泡排序的一种改进，采用递归分治的方法。相对于冒泡排序，快速排序是一种不稳定的排序，时间复杂度最坏是O(n^2), 平均时间复杂度为O(nlogn),最好情况的时间复杂度为O(nlogn)。

基本思想:
* 快排需要将序列变成两部分，就是 **序列左边全部小于一个数，序列右边全部到大于一个数**，然后利用递归的思想再将左序列当成一个完整的序列再进行排序，同样把序列的右侧也当成一个完整的序列进行排序。
* 其中这个数在这个序列中是可以随机取的，可以取最左边，可以取最右边，当然也可以取随机数。但是**通常**不优化情况我们取最左边的那个数。

![aqa](https://vip1.loli.net/2020/12/15/hf58rbZqjwFAYtp.gif){:width="300"}
_Quick Sort_


```java
private void quickSort(int[] a, int left, int right) {
    int low = left;
    int hight = right;
    int k = a[low]; //待排序的第一个元素作为基准元素
    if (low <= hight) { //待排序的元素至少有两个的情况
        if (low != hight) { //从左右两边交替扫描，直到low = hight
            while (low < hight && a[hight] >= k) {
                hight --;//从右往左扫描，找到第一个比基准元素小的元素
            }
            a[low] = a[hight];//找到这种元素a[low]后与a[hight]交换
            while (low < hight && a[low] >= k) {
                low--; //从左往右扫描，找到第一个比基准元素大的元素
            }
            a[hight] = a[low]; //找到这种元素a[low]后，与a[hight]交换
        }
        a[low] = k; //基准元素归位
        quickSort(a, left, low-1);//对基准元素左边的元素进行递归排序
        quickSort(a, low+1, right);//对基准元素右边的进行递归排序
    }
}
```

## 插入类排序
### 直接插入排序
直接插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对未排序的数据，在已排序序列中从后向前扫描，找到相应的位置并插入。时间复杂度为O(n^2)。

具体步骤:
* 选取当前位置(当前位置前面已经有序) 目标就是将当前位置数据插入到前面合适位置
* 向前枚举或者二分查找，找到待插入的位置
* 移动数组，赋值交换，达到插入效果


![](https://vip2.loli.net/2020/12/15/hvDLOydAawtfFmK.jpg){: width="300"}
_原始序列_

![insert](https://vip2.loli.net/2020/12/15/316CvjeKFSspfoi.gif){: width="350"}
_Insert Sort_


```java
private void insertSort(int[] a) {
    int temp = 0;
    for (int i = 1; i < a.length; i++) { // 未排序数据
        temp = a[i]; // 待插入的数
        for (int j = i - 1; j >= 0; j--) { // 已排序序列
            if (a[j] > temp) {
                a[j+1] = a[j];
                a[j] = temp;
            } else {
                break;
            }
        }
    }
}
```

### 希尔排序
希尔排序，也称递减增量排序法，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进的方法的:
* 插入排序在对几乎已经拍好序的数据时，效率高。即可以达到线性排序的效率。
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

希尔排序的基本思想:
&nbsp;&nbsp;&nbsp;&nbsp;先将待排序的记录序列分割成若干子序列分别进行直接插入序列，待整个序列中的记录“基本有序”时，再对全体记录依次进行直接插入序列。

算法的基本步骤:
1. 选择一个增量序列, t1, t2,... tk,其中ti > tj, tk = 1;
2. 按照增量序列个数 k， 对序列进行 k 趟排序；
3. 每趟排序，根据对应的增量 ti，将待排序序列分割成若干个长度为 m 的子序列，分别对各子序列进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表进行处理，表长度即为整个序列长度。

![](https://vip2.loli.net/2020/12/16/i7fp6CPK4bgA1F3.jpg){: width="400"}
_原始序列_

初始增量 gap = length / 2 = 5, 意味着整个序列被分成 5 组，如下图所示

![](https://vip2.loli.net/2020/12/16/UKJ7fmG49RdtuXh.jpg){: width="400"}
_gap = 5_

对这 5 组分别进行直接插入排序，然后缩小增量 gap = 5/2 = 2, 序列被分成 2 组，如下图所示

![](https://vip1.loli.net/2020/12/16/TV7ZpeDzwrfNs1Q.jpg){: width="400"}
_gap = 2_

对这 2 组分别进行直接插入排序，然后缩小增量 gap = 2/2 = 1, 序列被分成 1 组，如下图所示

![](https://vip1.loli.net/2020/12/16/VZejEtz6r5IfwGs.jpg){: width="400"}
_gap = 1_

对以上的数组进行直接插入排序，即可实现排序

![](https://vip1.loli.net/2020/12/16/rgR746QAZVvquoT.jpg){: width="400"}
_最终排序_


```java
private void shellSort(int[] a) {
    int d = a.length;
    int temp = 0;
    for (; d >= 1; d/=2) {
        for (int i = d; i < a.length; i++) {
            temp = a[i];
            for (int j = i-d; j >= 0 ; j-=d) {
                if (a[j] > temp) {
                    a[j+d] = a[j];
                    a[j] = temp;
                } else {
                    break;
                }
            }
        }
    }
}
```

![eeeee](https://vip2.loli.net/2020/12/16/jmHIQCt4WbFvO8D.gif){: width="400"}
_动态效果_

## 选择类排序
### 简单选择排序
简单选择排序是一种简单直观的排序方法。时间复杂度为 O(n^2),数据规模越小越好。

算法的基本步骤: 
* 首先在未排序的序列中找到最小（大）元素，存放到排序序列的起始位置
* 再从剩余未排序的元素中找到最小（大）元素，然后放到`已排序序列的末尾`
* 重复第二步，直到所有的元素均排序完毕

![232323](https://vip1.loli.net/2020/12/16/SQ3eNG5C89F6YMq.gif){: width="400"}
_动态效果_


```java
private void SelectionSort(int[] a) {
    for (int i = 0; i < a.length -1; i++) {
        int min = i;
        for (int j = i + 1; j < a.length; j++) {
            if (a[j] < a[min]) {
                min = j;
            }
        }
        if (min != i) {
            swap(a, i, min);
        }
    }
}

private void swap(int[] a, int i, int j) {
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
```












